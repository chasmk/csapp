### 统计一个目录中(包含子目录)中的代码行数
```
find . | grep '\.c$\|\.h$' | xargs wc -l
```

### 统计磁盘使用情况
以下命令统计/usr/share目录下各个目录所占用的磁盘空间:
```
du -sc /usr/share/* | sort -nr
```

### 编译运行c文件

gcc的-o选项指定了输出文件的名称
```
gcc hello.c -o hello
```
如果不使用-o选项, 则会默认生成名为a.out的文件, 它的含义是assembler output. 
在命令行输入
```
./hello
```
就能够运行改程序. 命令中的./是不能少的, 点代表了当前目录

### 使用重定向
有时我们希望将程序的输出信息保存到文件中, 方便以后查看. 例如你编译了一个程序myprog, 你可以使用以下命令对myprog进行反汇编, 并将反汇编的结果保存到output文件中:
```
objdump -d myprog > output
```
\>是标准输出重定向符号, 可以将前一命令的输出重定向到文件output中. 这样, 你就可以使用文本编辑工具查看output了.

但你会发现, 使用了输出重定向之后, 屏幕上就不会显示myprog输出的任何信息. 如果你希望输出到文件的同时也输出到屏幕上, 你可以使用tee命令:
```
objdump -d myprog | tee output
```
使用输出重定向还能很方便地实现一些常用的功能, 例如
```
> empty     # 创建一个名为empty的空文件

cat old_file > new_file  # 将文件old_file复制一份, 新文件名为new_file
```
如果myprog需要从键盘上读入大量数据(例如一个图的拓扑结构), 当你需要反复对myprog进行测试的时候, 你需要多次键入大量相同的数据. 为了避免这种无意义的重复键入, 你可以使用以下命令:
```
./myprog < data
```
<是标准输入重定向符号, 可以将前一命令的输入重定向到文件data中. 这样, 你只需要将myprog读入的数据一次性输入到文件data中, myprog就会从文件data中读入数据, 节省了大量的时间.

下面给出了一个综合使用重定向的例子:
```
time ./myprog < data | tee output
```
这个命令在运行myprog的同时, 指定其从文件data中读入数据, 并将其输出信息打印到屏幕和文件output中. time工具记录了这一过程所消耗的时间, 最后你会在屏幕上看到myprog运行所需要的时间. 如果你只关心myprog的运行时间, 你可以使用以下命令将myprog的输出过滤掉:
```
time ./myprog < data > /dev/null
```
/dev/null是一个特殊的文件, 任何试图输出到它的信息都会被丢弃, 你能想到这是怎么实现的吗? 总之, 上面的命令将myprog的输出过滤掉, 保留了time的计时结果, 方便又整洁.

### 使用Makefile管理工程
大规模的工程中通常含有几十甚至成百上千个源文件(Linux内核源码有25000+的源文件), 分别键入命令对它们进行编译是十分低效的. Linux提供了一个高效管理工程文件的工具: GNU Make. 我们首先从一个简单的例子开始, 考虑上文提到的Hello World的例子, 在`hello.c`所在目录下新建一个文件Makefile, 输入以下内容并保存:
```
hello:hello.c
    gcc hello.c -o hello    # 注意开头的tab, 而不是空格

.PHONY: clean

clean:
    rm hello    # 注意开头的tab, 而不是空格
```
返回命令行, 键入`make`, 你会发现`make`程序调用了`gcc`进行编译. `Makefile`文件由若干规则组成, 规则的格式一般如下:
```
目标文件名:依赖文件列表
    用于生成目标文件的命令序列   # 注意开头的tab, 而不是空格
```
我们来解释一下上文中的`hello`规则. 这条规则告诉`make`程序, 需要生成的目标文件是`hello`, 它依赖于文件`hello.c`, 通过执行命令`gcc hello.c -o hello`来生成`hello`文件.

如果你连续多次执行`make`, 你会得到"文件已经是最新版本"的提示信息, 这是`make`程序智能管理的功能. 如果目标文件已经存在, 并且它比所有依赖文件都要"新", 用于生成目标的命令就不会被执行. 你能想到`make`程序是如何进行"新"和"旧"的判断的吗?

上面例子中的`clean`规则比较特殊, 它并不是用来生成一个名为`clean`的文件, 而是用于清除编译结果, 并且它不依赖于其它任何文件. `make`程序总是希望通过执行命令来生成目标, 但我们给出的命令`rm hello`并不是用来生成`clean`文件, 因此这样的命令总是会被执行. 你需要键入`make clean`命令来告诉make程序执行`clean`规则, 这是因为`make`默认执行在`Makefile`中文本序排在最前面的规则. 但如果很不幸地, 目录下已经存在了一个名为`clean`的文件, 执行`make clean`会得到"文件已经是最新版本"的提示. 解决这个问题的方法是在`Makefile`中加入一行`PHONY: clean`, 用于指示"`clean`是一个伪目标". 这样以后, `make`程序就不会判断目标文件的新旧, 伪目标相应的命令序列总是会被执行.

对于一个规模稍大一点的工程, `Makefile`文件还会使用变量, 函数, 调用Shell命令, 隐含规则等功能. 如果你希望学习如何更好地编写一个`Makefile`, 请到互联网上搜索相关资料.